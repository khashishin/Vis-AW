<!DOCTYPE html>
<meta charset="utf-8">
<style>
.node {
    stroke: #fff;
    stroke-width: 1.5px;
}

.node text {
  pointer-events: none;
  font: 12px sans-serif;
  fill : black;
}

.link {
    stroke: #999;
    stroke-opacity: .6;
}

#selected {
  position:fixed;
  background-color: WHITE;
  border-radius: 4px;
  bottom: 0px;
  font: 12px sans-serif;
}

#header {
font: 50px arial;
margin: auto;
width: 38%;
}

#textInput{
float:right;
border:none;
position: fixed;
font: 28px arial;
}

#details{
position:relative;
font: 28px arial;
}

#cut_value{
position:fixed;
border: none;
margin-top:3px;
font: 20px arial;
}

#slider {
font:32px arial;
}
</style>


<body>
<div id="header">Wizualizacja dendrytu wrocławskiego</div>
	
<form>
    <div id="slider"> 
	Odetnij na poziomie średniej odległości + K odchyleń standardowych:  0     <input type="range" id="thresholdSlider" name="points" value = 0 min="0" max="4" onchange="threshold(this.value);  updateTextInput(this.value)" >     4
	</div>
	<div id="details">
	Aktualna wartość "odcinania" =   	<input id="cut_value" value="" readonly size="1">
	</div>
	<input type="text" id="textInput" value="" readonly size="1">
</form>
  
<div id='visualisation'>
<div id='selected'> <h1>Info</h1> </div>
</div>

<script src='d3.min.js'></script>
<script type="application/json" id="data">
{"nodes": [{"node": "Dolno\u015bl\u0105skie"}, {"node": "Kujawsko-pomorskie"}, {"node": "Lubelskie"}, {"node": "Lubuskie"}, {"node": "\u0141\u00f3dzkie"}, {"node": "Ma\u0142opolskie"}, {"node": "Mazowieckie"}, {"node": "Opolskie"}, {"node": "Podkarpackie"}, {"node": "Podlaskie"}, {"node": "Pomorskie"}, {"node": "\u015al\u0105skie"}, {"node": "\u015awi\u0119tokrzyskie"}, {"node": "Warmi\u0144sko-mazurskie"}, {"node": "Wielkopolskie"}, {"node": "Zachodniopomorskie"}], "std_dev": 0.4849826606736854, "links": [{"source": 0, "length": 257.23591973128526, "target": 10, "bond": 2}, {"source": 1, "length": 254.24151922925572, "target": 8, "bond": 2}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 2}, {"source": 3, "length": 488.93110199699925, "target": 5, "bond": 2}, {"source": 4, "length": 345.08210385356114, "target": 11, "bond": 2}, {"source": 5, "length": 488.93110199699925, "target": 3, "bond": 2}, {"source": 6, "length": 1877.5371498055638, "target": 11, "bond": 1}, {"source": 7, "length": 658.5055557092895, "target": 13, "bond": 2}, {"source": 8, "length": 254.24151922925572, "target": 1, "bond": 2}, {"source": 9, "length": 147.8552836391043, "target": 15, "bond": 2}, {"source": 10, "length": 257.23591973128526, "target": 0, "bond": 2}, {"source": 11, "length": 345.08210385356114, "target": 4, "bond": 2}, {"source": 12, "length": 414.6411244678945, "target": 14, "bond": 1}, {"source": 13, "length": 658.5055557092895, "target": 7, "bond": 2}, {"source": 14, "length": 224.86515959570067, "target": 2, "bond": 2}, {"source": 15, "length": 147.8552836391043, "target": 9, "bond": 2}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 8, "length": 254.24151922925572, "target": 1, "bond": 1}, {"source": 14, "length": 224.86515959570067, "target": 2, "bond": 1}, {"source": 5, "length": 488.93110199699925, "target": 3, "bond": 1}, {"source": 4, "length": 749.8211232687435, "target": 7, "bond": 1}, {"source": 7, "length": 749.8211232687435, "target": 4, "bond": 1}, {"source": 9, "length": 698.9317594729832, "target": 12, "bond": 1}, {"source": 14, "length": 224.86515959570067, "target": 2, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 11, "length": 345.08210385356114, "target": 4, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}, {"source": 2, "length": 224.86515959570067, "target": 14, "bond": 1}], "mean": 1.3783783783783783}</script>

<script>

//Reading threshold value from html slider element
function updateTextInput(val) { document.getElementById('textInput').value=val; }

//Constants for the SVG image that will be the background for our visualisation
var width = window.screen.width,
    height = window.screen.height
	// default radius of node
	r = 8
	//Offests sets the offset of text labels.
	offset=6;

//Append a SVG to the body of the html page. Assign this SVG as an object to svg
var svg = d3.select("#visualisation").append("svg")
    .attr("width", width)
    .attr("height", height);
	
//Definind ounding box that will b shown on visualisation
svg.append("svg:rect")
    .attr("width", width)
    .attr("height", height)
    .style("stroke", "#000")
	.style("fill", "WHITE");
	
//Set up the colour scale that will be used for differentiating nodes
var color = d3.scale.category20();

//Set up the force layout that is the base for showing nodes and graphs
var force = d3.layout.force()
    .charge(-120)
	//Gravity value defines eg. the behaviour of nodes when in unconnected state (how strong is the force of attraction/rejection between them )
	.gravity(0.012)
    .linkDistance(function(d) { return d.length+(2*r);})
    .size([width, height]);

//Read the data from the data element in HTML
var data = document.getElementById('data').innerHTML;
graph = JSON.parse(data);
r = define_node_radius();
graphRec = JSON.parse(JSON.stringify(graph)); //This line is used so the programm can read threshold values to cut

//With this function we define the size of a node based on the number of points we want to visualise, the method is more or less arbitraty fit the points visually.
function define_node_radius() {
var radius = 250/graph.nodes.length
if (radius<1) {radius=1}
if (radius > 20) {radius=20}
//Redefine text offset to be consistent with the node
offset = radius-5
return radius}

//Creates the graph data structure out of the json data that is imported into D3 force layout
force.nodes(graph.nodes)
    .links(graph.links)
    .start();

//Create all the line svgs in group marker, so we can add things to it if we want later (g) - empty, without coordinates
var link = svg.selectAll("g")
    .data(graph.links)
    .enter()
	.append("line")
    .attr("class", "link")
	.style("stroke-width", function(d) {if (d.bond>1) return (d.bond * 2 - 1) * 2 + "px"; })

//The same with nodes (circles)
var node = svg.selectAll("g")
    .data(graph.nodes)
    .enter()
	.append("g")
	.call(force.drag)
	.on("click", selectPoint)
	.on('dblclick', connectedNodes)	//Highlithing;
	
//Append SVG circle to the (g) element
var circles = node.append("circle")
    .attr("class", "node")
    .attr("r", r)
    .style("fill", function (d) {return color(d.node);})
	.style("stroke", "gray")

//Append text label to the element
var TextLabels = node.append("text")
				 .text(function(d) {return d.node; })

//Now we are giving the SVGs co-ordinates - the force layout is generating the co-ordinates which this code is using to update the attributes of the SVG elements
force.on("tick", function () {
    link.attr("x1", function (d) {return d.source.x;})
        .attr("y1", function (d) {return d.source.y;})
        .attr("x2", function (d) {return d.target.x;})
        .attr("y2", function (d) {return d.target.y;});
		
	circles.attr("cx", function(d) { return d.x = Math.max(r, Math.min(width - r+5, d.x)); })
        .attr("cy", function(d) { return d.y = Math.max(r, Math.min(height - r+5, d.y)); });

	TextLabels
	    .attr("x", function (d) {return d.x+offset;})
        .attr("y", function (d) {return d.y-offset;});
});

//Runs the threshold cutting for the first time when running visualisation, to cut it for K=0 (default)
threshold(document.getElementById('thresholdSlider').value);
//Adjust cutting/splicing links threshold
function threshold(thresh) {
	
    graph.links.splice(0, graph.links.length);
	var cutting_value= graph.mean +(thresh*graph.std_dev)

		for (var i = 0; i < graphRec.links.length; i++) {
			if (graphRec.links[i].length > cutting_value) {graph.links.push(graphRec.links[i]);}
		}
	
	document.getElementById('cut_value').value=(Math.round(cutting_value * 1000) / 1000);
    restart();
}

// What happens when you click node in graph
function selectPoint(d) {
	d3.select('#selected h1')
      .text("User: "+ d.node)
}

//Restart the visualisation after any node and link changes
function restart() {
	link = link
	.data(graph.links)
	.style("stroke-width", function(d) {if (d.bond>1) return (d.bond * 2 - 1) * 2 + "px"; })
	link.exit().remove();
	link
		.enter()
		.insert("line","g")
		.attr("class", "link")
		.style("stroke-width", function(d) {if (d.bond>1) return (d.bond * 2 - 1) * 2 + "px"; })
	force.start();
}

// Connected nodes doubleclick highlight
//Toggle stores whether the highlighting is on
var toggle = 0;
//Create an array logging what is connected to what
var linkedByIndex = {};
for (i = 0; i < graph.nodes.length; i++) {linkedByIndex[i + "," + i] = 1;};
graph.links.forEach(function (d) {linkedByIndex[d.source.index + "," + d.target.index] = 1;});
function neighboring(a, b) {return linkedByIndex[a.index + "," + b.index];}

function connectedNodes() {
    if (toggle == 0) {
        //Reduce the opacity of all but the neighbouring nodes
        d = d3.select(this).node().__data__;
        node.style("opacity", function (o) {return neighboring(d, o) | neighboring(o, d) ? 1 : 0.1;});
        link.style("opacity", function (o) {return d.index==o.source.index | d.index==o.target.index ? 1 : 0.1;});
        //Reduce the opacity
        toggle = 1;}
	
	else {
        //Put them back to opacity=1
        node.style("opacity", 1);
        link.style("opacity", 1);
        toggle = 0;}
}
</script>